<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>compsci &#8211; a2wd</title>
	<atom:link href="https://a2wd.github.io/tag/compsci/feed/" rel="self" type="application/rss+xml" />
	<link>http://a2wd.github.io/</link>
	<description>code &#38; design</description>
	<lastBuildDate>Mon, 25 Jul 2016 14:53:16 +0000</lastBuildDate>
	<language>en-GB</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.4.1</generator>

<image>
	<url>https://a2wd.github.io/content/2016/12/cropped-logo512-32x32.png</url>
	<title>compsci &#8211; a2wd</title>
	<link>http://a2wd.github.io/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>The mythical man-month</title>
		<link>https://a2wd.github.io/the-mythical-man-month/</link>
		
		<dc:creator><![CDATA[#!]]></dc:creator>
		<pubDate>Mon, 25 Jul 2016 14:53:16 +0000</pubDate>
				<category><![CDATA[Computer Science]]></category>
		<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[code]]></category>
		<category><![CDATA[compsci]]></category>
		<category><![CDATA[project management]]></category>
		<guid isPermaLink="false">https://a2wd.github.io/?p=263</guid>

					<description><![CDATA[The mythical man-month by Frederick Brooks is a now ancient classic on project management, with a focus on programming &#38; systems development. It has excellent advice on the subject which is mostly very relevant today. Some of the main lessons I took away from this book are: Time estimates &#38; planning Time estimates in software [&#8230;]]]></description>
										<content:encoded><![CDATA[<p>The mythical man-month <em>by Frederick Brooks</em> is a now ancient classic on project management, with a focus on programming &amp; systems development. It has excellent advice on the subject which is mostly very relevant today.</p>
<p>Some of the main lessons I took away from this book are:</p>
<h2>Time estimates &amp; planning</h2>
<p>Time estimates in software projects are often out by a long way. This is in part because not enough time is given to testing. Frederick&#8217;s advice is that if a component takes X time to build, it will take 2X time to test, on it&#8217;s own. On top of that it will also need another 2X integration testing time in addition to around 2X planning time. This is to say that the original estimate of X is likely to be out by at least a factor of 5.</p>
<h2>Team setup</h2>
<p>Another issue is that the larger a team, the less productive per-member the team. A team of one will mean ideas, architecture, set-up, bugs and the like don&#8217;t ever need to be communicated. Conversely, a team of 100 needs 100 times as many interactions to communicate basic details. Communication time which could be spent working on the problems at hand.</p>
<p>Obviously, some projects will require larger teams, but there is a strong incentive to keep the teams lean. Specifically, in his book, Brooks makes a comparison to a surgical team with one lead architect, a &#8216;co-pilot&#8217;, two team members and a couple of secretaries to deal with the administration.</p>
<p>There is a lot to be said for smaller, leaner teams.</p>
<h2>Project overrun</h2>
<p>When it looks like a project is over-running, project managers have a tendency to add more resource to the project. This in the end has the counter-productive outcome of taking the existing team off their current tasks to train up the new team-members in the project setup. This doesn&#8217;t solve the original problem and instead leads to more burnt man-hours.</p>
<p>The main lesson here is to add new team members early on and to trust the team to deliver later on.</p>
<h2>Higher level languages</h2>
<p>This was probably the most interesting section/takeaway. I was reading the 20th anniversary imprint of the book, itself now 10 years old. In it, Brooks talks about the incredible development gains made by adopting object-oriented programming languages (specifically, by moving to C++ instead of COBOL, ALGOL or Assembly).</p>
<p>With the subsequent increases in processing speeds, we will probably see similar improvements with functional programming. As per many recent medium articles (cf. <a href="https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53#.9oez8shnj">Goodbye, Object Oriented Programming</a>), for many projects, OOP is creaking and straining. There are a lot of gains to be made from functional techniques.</p>
<h2>Summary</h2>
<p>Keeping teams lean can really help companies deliver projects on time and to-budget. This is not just true in I.T. but many other disciplines too, however, it is especially important in I.T. to keep as small as possible. This sounds very close to agile and something I am currently exploring in Robert Martin&#8217;s <strong>Agile Principles, Patterns and Practices.</strong></p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
